package iota

import android.view.{View, ViewGroup}
import android.annotation.TargetApi
import android.widget._

/**
  * @author pfnguyen
  */
trait ViewTree[A <: ViewGroup] extends Iterable[ViewTree.Children] with Product {
  import ViewTree._

  /** @return an iterator with breadth-first traversal */
  override def iterator = new Iterator[Children] {
    var queue = collection.immutable.Queue[Children](Left(ViewTree.this))
    override def hasNext = queue.nonEmpty
    override def next() = {
      val (n, q) = queue.dequeue
      queue = q ++ (n match {
        case Left(vt) => vt.productIterator.map {
          case tree: ViewTree[_] => Left(tree)
          case view: View        => Right(view)
        }
        case Right(ch) => Nil
      })
      n
    }
  }

  def nest[B <: ViewGroup](views: View*)(body: Any): ViewTree[B] = macro ViewTreeMacro.nest[B]

  val container: A

  // implicits to allow implementations to access DSL
  final implicit def viewLayoutExtensions        [Z <: View](v: Z): ViewLayoutExtensions[Z]         = ViewLayoutExtensions(v)
  final implicit def viewLinearLayoutExtensions  [Z <: View](v: Z): ViewLinearLayoutExtensions[Z]   = ViewLinearLayoutExtensions(v)
  final implicit def viewRelativeLayoutExtensions[Z <: View](v: Z): ViewRelativeLayoutExtensions[Z] = ViewRelativeLayoutExtensions(v)
  final implicit def viewMarginLayoutExtensions  [Z <: View](v: Z): ViewMarginLayoutExtensions[Z]   = ViewMarginLayoutExtensions(v)
  final implicit def viewGravityLayoutExtensions [Z <: View](v: Z): ViewGravityLayoutExtensions[Z]  = ViewGravityLayoutExtensions(v)
}
object ViewTree extends ViewTreeBoilerplate.Inflate
  with ViewTreeBoilerplate.InflateF with ViewTreeBoilerplate.Check {
  /** an annotation to suppress warnings generated by `inflateF` */
  class UnsafeOperation extends annotation.StaticAnnotation
  type Children = Either[ViewTree[_], _ <: View]
  trait LayoutConstraint[A <: ViewGroup] extends Any
  /** a second layout type constraint, `OR`d with any other `LayoutConstraint` */
  trait LayoutConstraint2[A <: ViewGroup] extends Any
  trait LayoutParamConstraint[A <: ViewGroup.LayoutParams] extends Any
  case class ViewLayoutExtensions[A <: View](v: A) extends AnyVal {
    /** construct LayoutParams for the correct type with the specified arguments.
      * If `lp` is not called, any layout decorator call will insert default
      * LayoutParams. Default LayoutParams have WRAP_CONTENT for both width and height
      */
    def lp         [B <: A](args: Any*)(implicit ev: B =:= A): B = macro ViewTreeMacro.lp[A,B]
    def matchWidth [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField2[A,B]
    def matchHeight[B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField2[A,B]
    def wrapWidth  [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField2[A,B]
    def wrapHeight [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField2[A,B]
  }
  case class ViewGravityLayoutExtensions[A <: View](v: A) extends AnyVal with LayoutConstraint[LinearLayout] with LayoutConstraint2[FrameLayout] {
    def gravity[B <: A](value: Int)(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField[A,B]
  }
  case class ViewLinearLayoutExtensions[A <: View](v: A) extends AnyVal with LayoutConstraint[LinearLayout] {
    def weight[B <: A](value: Float)(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField[A,B]
  }
  case class ViewMarginLayoutExtensions[A <: View](v: A) extends AnyVal with LayoutParamConstraint[ViewGroup.MarginLayoutParams] {
    // would like a margins(t,l,r,b) but macros don't support default/named args
    def marginLeft  [B <: A](value: Int)(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField[A,B]
    def marginTop   [B <: A](value: Int)(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField[A,B]
    def marginBottom[B <: A](value: Int)(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField[A,B]
    def marginRight [B <: A](value: Int)(implicit ev: B =:= A): B = macro ViewTreeMacro.layoutParamField[A,B]
  }
  case class ViewRelativeLayoutExtensions[A <: View](v: View) extends AnyVal with LayoutConstraint[RelativeLayout] {
    def above                   [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def alignBaseLine           [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def alignBottom             [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    @TargetApi(17)
    def alignEnd                [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def alignLeft               [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def alignParentBottom       [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    @TargetApi(17)
    def alignParentEnd          [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    def alignParentLeft         [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    def alignParentRight        [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    @TargetApi(17)
    def alignParentStart        [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    def alignParentTop          [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    def alignRight              [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def alignWithParentIfMissing[B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutAlignParent[A,B]
    @TargetApi(17)
    def alignStart              [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def alignTop                [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def below                   [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def centerHorizontal        [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    def centerInParent          [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    def centerVertical          [B <: A]()(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutUnary[A,B]
    @TargetApi(17)
    def endOf                   [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def leftOf                  [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    def rightOf                 [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
    @TargetApi(17)
    def startOf                 [B <: A](view: View)(implicit ev: B =:= A): B = macro ViewTreeMacro.relativeLayoutParamView[A,B]
  }
}
